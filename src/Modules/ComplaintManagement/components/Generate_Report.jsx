import React, { useEffect, useState } from "react";
import { Paper, Badge, Button, Flex } from "@mantine/core";
import { useSelector } from "react-redux";
import "../styles/GenerateReport.css";
import detailIcon from "../../../assets/detail.png";
import declinedIcon from "../../../assets/declined.png";
import resolvedIcon from "../../../assets/resolved.png";

const complaintTypes = [
  "Electricity",
  "Carpenter",
  "Plumber",
  "Garbage",
  "Dustbin",
  "Internet",
  "Other",
];

const locations = [
  "Hall-1",
  "Hall-3",
  "Hall-4",
  "Nagarjun Hostel",
  "Maa Saraswati Hostel",
  "Panini Hostel",
  "LHTC",
  "CORE LAB",
  "CC1",
  "CC2",
  "Rewa Residency",
  "NR2",
];

function GenerateReport() {
  const [complaintsData, setComplaintsData] = useState([]);
  const [filteredData, setFilteredData] = useState([]);
  const [filters, setFilters] = useState({
    location: "",
    complaintType: "",
    status: "",
    startDate: "",
    endDate: "",
    sortBy: "",
  });
  const username = useSelector((state) => state.user.username);
  const role = useSelector((state) => state.user.role);

  const fetchComplaintsData = async () => {
    try {
      const response = await fetch(
        `http://127.0.0.1:8000/complaint/generate-report`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Token ${localStorage.getItem("authToken")}`,
          },
        },
      );

      if (!response.ok) throw new Error("Network response was not ok");
      const data = await response.json();
      console.log("Fetched data:", data);

      if (Array.isArray(data)) {
        setComplaintsData(data);
        setFilteredData(data);
      } else {
        console.error("Fetched data is not an array:", data);
        setComplaintsData([]);
        setFilteredData([]);
      }
    } catch (error) {
      console.error("Error fetching complaints data:", error);
    }
  };

  const applyFilters = () => {
    let filtered = [...complaintsData];

    // Apply location filter
    if (filters.location) {
      filtered = filtered.filter(
        (complaint) =>
          complaint.location.toLowerCase() === filters.location.toLowerCase(),
      );
    }
    // Apply complaint type filter
    if (filters.complaintType) {
      filtered = filtered.filter(
        (complaint) =>
          complaint.complaint_type.toLowerCase() ===
          filters.complaintType.toLowerCase(),
      );
    }

    // Apply status filter
    if (filters.status) {
      filtered = filtered.filter(
        (complaint) => String(complaint.status) === filters.status,
      );
    }

    // Apply date filters
    if (filters.startDate) {
      filtered = filtered.filter(
        (complaint) =>
          new Date(complaint.complaint_date) >= new Date(filters.startDate),
      );
    }

    if (filters.endDate) {
      filtered = filtered.filter(
        (complaint) =>
          new Date(complaint.complaint_date) <= new Date(filters.endDate),
      );
    }

    // Apply sorting
    if (filters.sortBy) {
      if (filters.sortBy === "status") {
        filtered.sort((a, b) => {
          return a.status - b.status;
        });
      } else if (filters.sortBy === "mostRecent") {
        filtered.sort(
          (a, b) => new Date(b.complaint_date) - new Date(a.complaint_date),
        );
      } else if (filters.sortBy === "mostOlder") {
        filtered.sort(
          (a, b) => new Date(a.complaint_date) - new Date(b.complaint_date),
        );
      }
    }

    setFilteredData(filtered);
  };

  useEffect(() => {
    fetchComplaintsData();
  }, []);

  useEffect(() => {
    applyFilters();
  }, [filters, complaintsData]);

  const handleFilterChange = (event) => {
    const { name, value } = event.target;
    setFilters((prevFilters) => ({
      ...prevFilters,
      [name]: value,
    }));
  };

  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString();
  };

  const statusMapping = {
    0: "Pending",
    2: "Resolved",
    3: "Declined",
  };

  const generateCSV = () => {
    if (!filteredData.length) {
      console.error("No data to generate CSV");
      alert("No data to generate CSV");
      return;
    }

    const currentDateTime = new Date().toLocaleString().replace(",", "");
    const reportTitle = `Complaint Report`;
    const dateLine = `Date of Generation: ${currentDateTime}`;
    const userLine = `Generated by: ${username}`;

    // Get selected filters and include all relevant filters
    const complaintType = filters.complaintType
      ? `Complaint Type: ${filters.complaintType}`
      : "";
    const location = filters.location ? `Location: ${filters.location}` : "";
    const status = filters.status
      ? `Status: ${statusMapping[filters.status]}`
      : "";
    const startDate = filters.startDate
      ? `From Date: ${filters.startDate}`
      : "";
    const endDate = filters.endDate ? `To Date: ${filters.endDate}` : "";

    const appliedFilters = [
      complaintType && [complaintType],
      location && [location],
      status && [status],
      startDate && [startDate],
      endDate && [endDate],
    ].filter(Boolean);

    // CSV headers
    const headers = ["Complaint Type", "Location", "Status", "Date", "Details"];

    // Create rows from complaints data
    const rows = filteredData.map((complaint) => [
      complaint.complaint_type,
      complaint.location,
      statusMapping[complaint.status] || "Pending",
      formatDate(complaint.complaint_date),
      complaint.details.replace(/,/g, ""), // Remove commas to prevent CSV formatting issues
    ]);

    const csvContent = [
      [reportTitle],
      [dateLine],
      [userLine],
      ...appliedFilters,
      [],
      headers,
      ...rows,
    ]
      .map((row) => row.join(","))
      .join("\n");

    return csvContent;
  };

  const downloadCSV = () => {
    const csvData = generateCSV();

    if (!csvData) return;

    // Create a Blob from the CSV data
    const blob = new Blob([csvData], { type: "text/csv" });

    // Create a download link and simulate a click
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "Complaint Report.csv";
    link.click();
  };

  return (
    <div className="full-width-container">
      <Paper
        radius="md"
        px="lg"
        pt="sm"
        pb="xl"
        style={{
          borderLeft: "0.6rem solid #15ABFF",
          width: "60vw",
          minHeight: "45vh",
          maxHeight: "78vh",
          overflowY: "auto",
        }}
        withBorder
        maw="1240px"
        backgroundColor="white"
      >
        <Flex direction="column">
          {filteredData.length > 0 ? (
            filteredData.map((complaint, index) => {
              const displayedStatus =
                complaint.status in statusMapping ? complaint.status : 0;

              return (
                <Paper
                  key={index}
                  radius="md"
                  px="lg"
                  pt="sm"
                  pb="xl"
                  className="complaint-subcard"
                  withBorder
                >
                  <div className="complaint-header-container">
                    <div className="complaint-header">
                      <span>Complaint Id: {complaint.id}</span>
                    </div>
                    <Badge
                      id="complaint-type-badge"
                      style={{ marginRight: "20px" }}
                    >
                      {complaint.complaint_type}
                    </Badge>
                    <div className="details-status-container">
                      <div className="status-section">
                        {statusMapping[displayedStatus] && (
                          <img
                            src={
                              statusMapping[displayedStatus] === "Resolved"
                                ? resolvedIcon
                                : statusMapping[displayedStatus] === "Declined"
                                  ? declinedIcon
                                  : detailIcon
                            }
                            alt={statusMapping[displayedStatus]}
                            className="status-icon"
                          />
                        )}
                      </div>
                    </div>
                  </div>

                  <div className="complaint-detail">
                    <b>Date : </b>
                    <span id="content-generate">
                      {formatDate(complaint.complaint_date)}
                    </span>
                  </div>

                  <div className="complaint-detail">
                    <b>Location : </b>
                    <span id="content-generate">{complaint.location}</span>
                  </div>

                  <div className="complaint-detail">
                    <b>Complaint : </b>
                    <span id="content">{complaint.details.split(".")[0]}</span>
                  </div>

                  <div id="hr">
                    <hr />
                  </div>

                  <div className="complaint-detail">{complaint.details}</div>
                </Paper>
              );
            })
          ) : (
            <p>No complaints found.</p>
          )}
        </Flex>
      </Paper>

      <div className="filter-card-container">
        <h2>Filters</h2>

        {role.includes("supervisor") && (
          <>
            <div className="filter-label">Location</div>
            <select name="location" onChange={handleFilterChange}>
              <option value="">Select Location</option>
              {locations.map((loc) => (
                <option key={loc} value={loc}>
                  {loc}
                </option>
              ))}
            </select>
          </>
        )}

        {(role.includes("caretaker") || role.includes("convener")) && (
          <>
            <div className="filter-label">Complaint Type</div>
            <select name="complaintType" onChange={handleFilterChange}>
              <option value="">Select Complaint Type</option>
              {complaintTypes.map((type) => (
                <option key={type} value={type}>
                  {type}
                </option>
              ))}
            </select>
          </>
        )}

        <div className="filter-label">Status</div>
        <select name="status" onChange={handleFilterChange}>
          <option value="">Select Status</option>
          <option value="0">Pending</option>
          <option value="2">Resolved</option>
          <option value="3">Declined</option>
        </select>

        <div className="filter-label">From Date</div>
        <input type="date" name="startDate" onChange={handleFilterChange} />

        <div className="filter-label">To Date</div>
        <input type="date" name="endDate" onChange={handleFilterChange} />

        <div className="filter-label">Sort By</div>
        <select name="sortBy" onChange={handleFilterChange}>
          <option value="">Sort By</option>
          <option value="mostRecent">Most Recent</option>
          <option value="mostOlder">Most Older</option>
          <option value="status">Status</option>
        </select>

        <Flex direction="row-reverse">
          <Button onClick={downloadCSV} size="xs" variant="outline">
            Download CSV
          </Button>
        </Flex>
      </div>
    </div>
  );
}

export default GenerateReport;
